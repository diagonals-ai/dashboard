<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Grid Sequence Animation – Pac-Man Edition</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;display:flex;justify-content:center;align-items:center;min-height:100vh;overflow:hidden}
canvas{display:block}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');

// ─── Sizing ───
let W, H, CELL, BOX, OX, OY;
function resize() {
  W = cvs.width = window.innerWidth;
  H = cvs.height = window.innerHeight;
  const g = Math.min(W, H) * 0.82;
  CELL = g / 3;
  BOX = CELL * 0.16;
  OX = (W - g) / 2;
  OY = (H - g) / 2;
}
resize();
window.addEventListener('resize', () => { resize(); buildDots(); });

// ─── Helpers ───
function xy(i) {
  const n = i - 1;
  return { x: OX + (n % 4) * CELL, y: OY + ((n / 4) | 0) * CELL };
}
function ease(t) { return t < .5 ? 2*t*t : -1+(4-2*t)*t; }

function lerpDirect(from, to, t) {
  const a = xy(from), b = xy(to);
  const et = ease(t);
  return { x: a.x + (b.x - a.x) * et, y: a.y + (b.y - a.y) * et };
}

// ─── Sequences ───
const SEQUENCES = [
  {
    cells: [10, 6, 7, 11, 10],
    color: '#3399ff',       // blue
    wall: '#1a4d80'
  },
  {
    cells: [10, 6, 10, 7, 11, 6, 10, 9, 10, 14, 10],
    color: '#ff8c1a',       // orange
    wall: '#804600'
  },
  {
    cells: [10, 13, 10, 6, 7, 3, 4, 8, 7, 11, 6, 1, 2, 5, 6, 10, 11, 12, 16, 15, 10],
    color: '#ffdd22',       // yellow
    wall: '#806e11'
  },
  {
    cells: [10, 6, 7, 11, 10, 7, 6, 11, 7, 3, 6, 5, 1, 2, 6, 10, 14, 13, 10, 7, 4, 8, 12, 16, 11, 10, 10],
    color: '#22dd66',       // green
    wall: '#116633'
  }
];

// ─── Timing ───
const HOLD_T  = 600;
const MOVE_T  = 500;
const PULSE_T = 500;
const PAUSE_T = 1500;
const FADEOUT_T = 800;

// ─── State ───
let seqIdx = 0, step = 0;
let phase = 'fadein';
let pt = 0, fc = 0, t0 = 0;
let trail = [];
const glow = new Float32Array(16);
let curSeq = SEQUENCES[0];

// Path lines
let pathSegments = [];
let lineOpacity = 1;

// Pac-Man state
let pacAngle = 0;       // facing direction in radians
let pacPos = null;       // {x,y}

// ─── Dot grid (Pac-Man pellets) ───
const DOTS_PER_SEG = 4;  // dots between each pair of adjacent cells
const EAT_RADIUS_SQ = 0; // will be set after resize
let dots = [];            // [{x,y,eaten}]
let eatR2 = 0;

function buildDots() {
  dots = [];
  // Uniform grid of dots covering the entire area
  // Same spacing as between cells: CELL / (DOTS_PER_SEG + 1)
  const step = CELL / (DOTS_PER_SEG + 1);
  const cols = 3 * (DOTS_PER_SEG + 1) + 1;  // total columns of dots
  const rows = 3 * (DOTS_PER_SEG + 1) + 1;  // total rows of dots
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      dots.push({ x: OX + c * step, y: OY + r * step, eaten: false });
    }
  }
  // Eat radius based on dot spacing
  eatR2 = (step * 0.55) * (step * 0.55);
}

function resetDots() {
  for (const d of dots) d.eaten = false;
}

function eatNearby(px, py) {
  for (const d of dots) {
    if (d.eaten) continue;
    const dx = d.x - px, dy = d.y - py;
    if (dx*dx + dy*dy < eatR2) d.eaten = true;
  }
}

// ─── Draw symbol ───
function drawSym(idx, cx, cy, sz, a) {
  ctx.save();
  const col = `rgba(180,200,230,${a})`;
  ctx.fillStyle = col;
  ctx.strokeStyle = col;
  ctx.lineWidth = 1.5;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  const s = sz * 0.6;
  const numMap = {10:'1', 6:'2', 7:'3', 11:'4'};

  switch(idx) {
    case 1: case 2: case 5: {
      const ch = idx===1?'B':idx===2?'C':'A';
      ctx.font = `600 ${sz*1.15}px Georgia,serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(ch, cx, cy+sz*0.03);
    } break;
    case 6: case 7: case 10: case 11: {
      ctx.font = `700 ${sz*1.2}px 'Helvetica Neue',Arial,sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(numMap[idx], cx, cy+sz*0.04);
    } break;
    case 3:
      ctx.beginPath();
      ctx.moveTo(cx-s*.55,cy); ctx.lineTo(cx+s*.55,cy);
      ctx.moveTo(cx,cy-s*.55); ctx.lineTo(cx,cy+s*.55);
      ctx.stroke(); break;
    case 4:
      ctx.beginPath();
      ctx.moveTo(cx-s*.45,cy-s*.18); ctx.lineTo(cx+s*.45,cy-s*.18);
      ctx.moveTo(cx-s*.45,cy+s*.18); ctx.lineTo(cx+s*.45,cy+s*.18);
      ctx.stroke(); break;
    case 8:
      ctx.beginPath();
      ctx.moveTo(cx-s*.45,cy); ctx.lineTo(cx+s*.45,cy);
      ctx.stroke(); break;
    case 9: {
      const h=s*.32;
      ctx.strokeRect(cx-h,cy-h,h*2,h*2);
    } break;
    case 12:
      ctx.beginPath(); ctx.arc(cx,cy,s*.43,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(cx,cy,2.5,0,Math.PI*2); ctx.fill();
      break;
    case 13:
      ctx.beginPath(); ctx.arc(cx,cy,s*.42,0,Math.PI*2); ctx.stroke();
      break;
    case 14: {
      const r=s*.45;
      ctx.beginPath(); ctx.moveTo(cx,cy-r);
      ctx.lineTo(cx+r*.87,cy+r*.5);
      ctx.lineTo(cx-r*.87,cy+r*.5);
      ctx.closePath(); ctx.stroke();
    } break;
    case 15: {
      const or_=s*.48, ir_=or_*.38;
      ctx.beginPath();
      for(let i=0;i<10;i++){
        const ang=-Math.PI/2+i*Math.PI/5;
        const r=i%2?ir_:or_;
        ctx[i?'lineTo':'moveTo'](cx+Math.cos(ang)*r, cy+Math.sin(ang)*r);
      }
      ctx.closePath(); ctx.stroke();
    } break;
    case 16: {
      const mr=s*.42, off=mr*.4, ir=mr*.75;
      const xi=(ir*ir-mr*mr-off*off)/(2*off);
      const yi2=mr*mr-xi*xi;
      if(yi2>0){
        const yi=Math.sqrt(yi2);
        ctx.beginPath();
        ctx.arc(cx,cy,mr,Math.atan2(-yi,xi),Math.atan2(yi,xi),false);
        ctx.arc(cx-off,cy,ir,Math.atan2(yi,xi+off),Math.atan2(-yi,xi+off),true);
        ctx.closePath(); ctx.fill();
      }
    } break;
  }
  ctx.restore();
}

// ─── Draw cell (maze style) ───
function drawCell(i) {
  const {x,y} = xy(i);
  const g = glow[i-1];
  const half = BOX;
  ctx.save();
  const c = curSeq;

  // Glow
  if(g>.03){
    const gr = ctx.createRadialGradient(x,y,0,x,y,BOX*4);
    gr.addColorStop(0, `rgba(255,255,0,${g*.12})`);
    gr.addColorStop(1, 'rgba(255,255,0,0)');
    ctx.fillStyle = gr;
    ctx.fillRect(x-BOX*4,y-BOX*4,BOX*8,BOX*8);
  }

  // Cell border (maze wall style)
  const a = .2 + g*.6;
  ctx.strokeStyle = g>.08 ? c.color : `rgba(33,33,222,${a})`;
  ctx.lineWidth = 2 + g;
  // Rounded rect for maze feel
  const r = half * 0.25;
  ctx.beginPath();
  ctx.moveTo(x-half+r, y-half);
  ctx.lineTo(x+half-r, y-half);
  ctx.quadraticCurveTo(x+half, y-half, x+half, y-half+r);
  ctx.lineTo(x+half, y+half-r);
  ctx.quadraticCurveTo(x+half, y+half, x+half-r, y+half);
  ctx.lineTo(x-half+r, y+half);
  ctx.quadraticCurveTo(x-half, y+half, x-half, y+half-r);
  ctx.lineTo(x-half, y-half+r);
  ctx.quadraticCurveTo(x-half, y-half, x-half+r, y-half);
  ctx.closePath();
  ctx.stroke();

  ctx.shadowBlur = 0;
  drawSym(i, x, y, half*.9, .2+g*.7);
  ctx.restore();
}

// ─── Maze-style grid lines ───
function drawLines() {
  ctx.save();
  ctx.strokeStyle = 'rgba(33,33,222,0.12)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([4, 8]);
  for(let r=0;r<4;r++) for(let c=0;c<4;c++){
    const i=r*4+c+1, p=xy(i);
    if(c<3){ const n=xy(i+1); ctx.beginPath(); ctx.moveTo(p.x+BOX,p.y); ctx.lineTo(n.x-BOX,p.y); ctx.stroke(); }
    if(r<3){ const n=xy(i+4); ctx.beginPath(); ctx.moveTo(p.x,p.y+BOX); ctx.lineTo(p.x,n.y-BOX); ctx.stroke(); }
  }
  ctx.setLineDash([]);
  ctx.restore();
}

// ─── Draw dot grid (pellets) ───
function drawDots() {
  ctx.save();
  const dotR = CELL * 0.018;
  for (const d of dots) {
    if (d.eaten) continue;
    ctx.fillStyle = 'rgba(255,184,108,0.85)';
    ctx.beginPath();
    ctx.arc(d.x, d.y, dotR, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

// ─── Draw Pac-Man ───
function drawPacMan(x, y, angle, now) {
  const r = BOX * 0.55;  // smaller Pac-Man
  // Chomp animation – faster when moving
  const speed = phase === 'flow' ? 0.018 : 0.006;
  const chomp = Math.abs(Math.sin(now * speed)) * 0.45;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);

  // Body
  ctx.fillStyle = '#ffdd00';
  ctx.shadowColor = 'rgba(255,221,0,0.4)';
  ctx.shadowBlur = 8;
  ctx.beginPath();
  ctx.arc(0, 0, r, chomp, Math.PI * 2 - chomp);
  ctx.lineTo(0, 0);
  ctx.closePath();
  ctx.fill();

  // Eye
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(r * 0.12, -r * 0.38, r * 0.16, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

// ─── Draw path lines ───
function drawPathLines() {
  if (pathSegments.length === 0) return;
  const c = curSeq;
  ctx.save();
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  for (let i = 0; i < pathSegments.length; i++) {
    const seg = pathSegments[i];
    const a = xy(seg.from), b = xy(seg.to);
    const age = 1 - i / (pathSegments.length + 5);
    const alpha = lineOpacity * (0.25 + 0.35 * age);

    // Glow
    ctx.strokeStyle = `${c.color}${Math.round(alpha*0.3*255).toString(16).padStart(2,'0')}`;
    ctx.lineWidth = 5;
    ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();

    // Core line
    ctx.strokeStyle = `${c.color}${Math.round(alpha*255).toString(16).padStart(2,'0')}`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
  }
  ctx.restore();
}

// ─── Draw active segment ───
function drawActiveSegment(fromCell, progress) {
  const toCell = SEQUENCES[seqIdx].cells[step + 1];
  if (fromCell === toCell) return;
  const c = curSeq;
  const a = xy(fromCell), b = xy(toCell);
  const ex = a.x + (b.x - a.x) * ease(progress);
  const ey = a.y + (b.y - a.y) * ease(progress);

  ctx.save();
  ctx.lineCap = 'round';
  ctx.strokeStyle = `${c.color}40`;
  ctx.lineWidth = 5;
  ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(ex, ey); ctx.stroke();
  ctx.strokeStyle = `${c.color}99`;
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(ex, ey); ctx.stroke();
  ctx.restore();
}

// ─── Advance ───
function nextStep(now) {
  const seq = SEQUENCES[seqIdx];
  const from = seq.cells[step], to = seq.cells[step + 1];
  if (from !== to) pathSegments.push({ from, to });
  step++;
  if (step >= seq.cells.length - 1) {
    phase = 'fadeout';
    pt = now;
    trail = [];
  } else {
    phase = 'hold';
    pt = now;
  }
}

// ─── Init dots ───
buildDots();

// ─── Main loop ───
function frame(now) {
  requestAnimationFrame(frame);
  if(!t0){ t0=now; pt=now; }
  const el = now - pt;
  glow.fill(0);
  let particle = null;

  const seq = SEQUENCES[seqIdx];
  curSeq = seq;

  if (phase === 'fadeout') {
    const t = Math.min(1, el / FADEOUT_T);
    lineOpacity = 1 - ease(t);
    const cur = seq.cells[step];
    glow[cur-1] = (1-t) * 0.6;
    // Pac-Man stays at last cell
    pacPos = xy(cur);
    if (t >= 1) {
      phase = 'pause';
      pt = now;
      pathSegments = [];
      lineOpacity = 1;
      pacPos = null;
    }
  }
  else if (phase === 'pause') {
    pacPos = null;
    if (el >= PAUSE_T) {
      seqIdx = (seqIdx+1) % SEQUENCES.length;
      step = 0;
      phase = 'fadein';
      pt = now;
      curSeq = SEQUENCES[seqIdx];
      pathSegments = [];
      lineOpacity = 1;
      resetDots();
    }
  }
  else if (phase === 'fadein') {
    const cur = seq.cells[step];
    const t = Math.min(1, el / 400);
    glow[cur-1] = ease(t);
    pacPos = xy(cur);
    eatNearby(pacPos.x, pacPos.y);
    if (t >= 1) { phase = 'hold'; pt = now; }
  }
  else if (phase === 'hold') {
    const cur = seq.cells[step];
    glow[cur-1] = 0.9 + 0.1 * Math.cos(el*.005);
    pacPos = xy(cur);
    eatNearby(pacPos.x, pacPos.y);
    if (el >= HOLD_T) {
      const nxt = seq.cells[step+1];
      if (cur === nxt) {
        phase = 'pulse'; pt = now;
      } else {
        phase = 'flow'; pt = now; trail = [];
        // Calculate angle toward next cell
        const a = xy(cur), b = xy(nxt);
        pacAngle = Math.atan2(b.y-a.y, b.x-a.x);
      }
    }
  }
  else if (phase === 'pulse') {
    const cur = seq.cells[step];
    const t = Math.min(1, el / PULSE_T);
    glow[cur-1] = 0.5 + 0.5 * Math.sin(t * Math.PI);
    pacPos = xy(cur);
    if (t >= 1) nextStep(now);
  }
  else if (phase === 'flow') {
    const cur = seq.cells[step];
    const nxt = seq.cells[step+1];
    const t = Math.min(1, el / MOVE_T);

    glow[cur-1] = Math.max(0, 1-t*1.6);
    if (t>.55) glow[nxt-1] = ease((t-.55)/.45);

    particle = lerpDirect(cur, nxt, t);
    pacPos = particle;
    eatNearby(pacPos.x, pacPos.y);

    // Update facing angle
    const a = xy(cur), b = xy(nxt);
    pacAngle = Math.atan2(b.y-a.y, b.x-a.x);

    if (fc%2===0) { trail.unshift({...particle}); if(trail.length>14) trail.pop(); }
    if (t >= 1) { trail=[]; particle=null; nextStep(now); }
  }

  // ─── Render ───
  ctx.clearRect(0,0,W,H);
  drawLines();
  drawPathLines();
  if (phase==='flow') {
    const cur = seq.cells[step];
    const t = Math.min(1, el / MOVE_T);
    drawActiveSegment(cur, t);
  }
  drawDots();
  for (let i=1; i<=16; i++) drawCell(i);
  if (pacPos) drawPacMan(pacPos.x, pacPos.y, pacAngle, now);
  fc++;
}

requestAnimationFrame(frame);
})();
</script>
</body>
</html>
